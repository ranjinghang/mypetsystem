// CHeaderCtrlCl.cpp: 实现文件
//

#include "stdafx.h"
#include "animals.h"
#include "CHeaderCtrlCl.h"


// CHeaderCtrlCl

IMPLEMENT_DYNAMIC(CHeaderCtrlCl, CHeaderCtrl)

CHeaderCtrlCl::CHeaderCtrlCl()
	: m_R(171)
	, m_G(199)
	, m_B(235)
	, m_Gradient(8)
{
	m_Format = "";
	m_Height = 1;
	m_fontHeight = 15;
	m_fontWith = 0;
	m_color = RGB(0, 0, 0);
}

CHeaderCtrlCl::~CHeaderCtrlCl()
{

}


BEGIN_MESSAGE_MAP(CHeaderCtrlCl, CHeaderCtrl)
	ON_WM_PAINT()
	ON_MESSAGE(HDM_LAYOUT, OnLayout)
END_MESSAGE_MAP()

// CHeaderCtrlCl 消息处理程序
void CHeaderCtrlCl::OnPaint()
{
	CPaintDC dc(this); // device context for painting
					   // TODO: 在此处添加消息处理程序代码
					   // 不为绘图消息调用 CHeaderCtrl::OnPaint()
	int nItem;
	nItem = GetItemCount();//得到有几个单元 
	for (int i = 0; i < nItem; i++)
	{
		CRect tRect;
		GetItemRect(i, &tRect);//得到Item的尺寸
		int R = m_R, G = m_G, B = m_B;

		CRect nRect(tRect);//拷贝尺寸到新的容器中 
		nRect.left++;//留出分割线的地方 

		CRgn rgn1;
		RECT tr = { nRect.left - 1, nRect.top, nRect.right, nRect.bottom };
		rgn1.CreateRectRgnIndirect(&tr);

		//内嵌窗体颜色绘制
		CBrush brush1(RGB(R, G, B));
		dc.FillRgn(&rgn1, &brush1);

		//内嵌窗体边框绘制
		CBrush brush2(RGB(209, 209, 209));
		dc.FrameRgn(&rgn1, &brush2, 1, 1);

		brush1.DeleteObject(); //释放画刷
		brush2.DeleteObject(); //释放画刷 


		//绘制立体背景
			//for(int j = tRect.top;j<=tRect.bottom;j++) 
			//{ 
			//	nRect.bottom = nRect.top+1; 
			//	CBrush _brush; 
			//	_brush.CreateSolidBrush(RGB(R,G,B));//创建画刷 
			//	dc.FillRect(&nRect,&_brush); //填充背景 
			//	_brush.DeleteObject(); //释放画刷 
			//	R-=m_Gradient;G-=m_Gradient;B-=m_Gradient;
			//	if (R<0)R = 0;
			//	if (G<0)G = 0;
			//	if (B<0)B= 0;
			//	nRect.top = nRect.bottom; 
			//} 
			dc.SetBkMode(TRANSPARENT);
		CFont nFont, * nOldFont;
		//dc.SetTextColor(RGB(250,50,50)); 
		dc.SetTextColor(m_color);
		nFont.CreateFont(m_fontHeight, m_fontWith, 0, 0, 0, FALSE, FALSE, 0, 0, 0, 0, 0, 0, _TEXT("黑体"));//创建字体 
		nOldFont = dc.SelectObject(&nFont);

		UINT nFormat = 1;
		if (m_Format[i] == '0')
		{
			nFormat = DT_LEFT;
			tRect.left += 3;
		}
		else if (m_Format[i] == '1')
		{
			nFormat = DT_CENTER;
		}
		else if (m_Format[i] == '2')
		{
			nFormat = DT_RIGHT;
			tRect.right -= 3;
		}
		TEXTMETRIC metric;
		dc.GetTextMetrics(&metric);
		int ofst = 0;
		ofst = tRect.Height() - metric.tmHeight;
		tRect.OffsetRect(0, ofst / 2);
		dc.DrawText(m_HChar[i], &tRect, nFormat);
		dc.SelectObject(nOldFont);
		nFont.DeleteObject(); //释放字体 
	}
	//画头部剩余部分 不绘制
		//CRect rtRect;
		//CRect clientRect;
		//GetItemRect(nItem - 1,rtRect);
		//GetClientRect(clientRect);
		//rtRect.left = rtRect.right+1;
		//rtRect.right = clientRect.right;
		//int R = m_R,G = m_G,B = m_B;
		//CRect nRect(rtRect);
		//绘制立体背景
		//for(int j = rtRect.top;j<=rtRect.bottom;j++) 
		//{ 
		//	nRect.bottom = nRect.top+1; 
		//	CBrush _brush; 
		//	_brush.CreateSolidBrush(RGB(R,G,B));//创建画刷 
		//	dc.FillRect(&nRect,&_brush); //填充背景 
		//	_brush.DeleteObject(); //释放画刷 
		//	R-=m_Gradient;G-=m_Gradient;B-=m_Gradient;
		//	if (R<0)R = 0;
		//	if (G<0)G = 0;
		//	if (B<0)B= 0;
		//	nRect.top = nRect.bottom; 
		//}
}

LRESULT CHeaderCtrlCl::OnLayout(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = CHeaderCtrl::DefWindowProc(HDM_LAYOUT, 0, lParam);
	HD_LAYOUT& hdl = *(HD_LAYOUT*)lParam;
	RECT* prc = hdl.prc;
	WINDOWPOS* pwpos = hdl.pwpos;

	//表头高度为原来1.5倍，如果要动态修改表头高度的话，将1.5设成一个全局变量 
	int nHeight = (int)(pwpos->cy * m_Height);
	pwpos->cy = nHeight;
	prc->top = nHeight;
	return lResult;
}